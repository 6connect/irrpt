#!/usr/local/bin/php
<?php

$currentpath = dirname(realpath(__FILE__));
require("{$currentpath}/../conf/irrpt.conf");
require("{$currentpath}/../inc/irrquery.inc");
require("{$currentpath}/../inc/aggregate.inc");
require("{$currentpath}/../inc/status.inc");
require("{$currentpath}/../inc/ipv6.inc");

$o_aggregate	= 0;	/* Default: do not aggregate prefixes */
$o_verbose	= 0;	/* Default: verbose mode off */
$o_4 = 0; /* Default to fetch both v4 and v6 by setting this to 0 */
$o_6 = 0; /* Default to fetch both v4 and v6 by setting this to 0 */

$irr		= new IRRQuery;	/* Open our IRRQuery class */



/* Parse through the cmdline options. */
for ($offset = 1; $offset < $_SERVER['argc']; $offset++) {
	if (substr($_SERVER['argv'][$offset], 0, 1) != "-")
		break;

	switch($_SERVER['argv'][$offset]) {
	    case "-h":
	    case "--help":
		printf("Usage: %s [-h46va] <object>\n", $_SERVER['argv'][0]);
		exit(1);

	    case "-v":
	    case "--verbose":
		$o_verbose = 1;
		break;

	    case "-a":
	    case "--aggregate":
		$o_aggregate = 1;
		break;

	    case "-4":
	    case "--4":
		$o_4 = 1;
		break;

	    case "-6":
	    case "--6":
		$o_6 = 1;
		break;
	}
}

if (($_SERVER['argc'] - $offset) < 1) {
	printf("Usage: %s [-h46va] <object>\n", $_SERVER['argv'][0]);
	exit(1);
}

$object = $_SERVER['argv'][$offset+0];



/* Establish a connection with our IRR Query whois server */
if ($irr->connect($cfg['fetch']['host'], $cfg['fetch']['port']) == FALSE) {
	status(STATUS_ERROR, "Unable to connect to IRR Query whois server, aborting.");
	exit(-1);
}

/* Optionally enable a local cache of prefixes per aut-num record */
if ($cfg['fetch']['cache']) {
	$irr->cache_set(TRUE);
}

/* If the user doesn't want to query all IRR sources, set the new sources now */
if ($cfg['fetch']['sources'] != "all")
	$irr->set_sources($cfg['fetch']['sources']);

/* Figure out if we have an AUT-NUM or an AS-SET, and resolve it */
status(STATUS_NOTICE, "Querying IRR Object {$object}");
$routes = array();
$routes4 = array();
$routes6 = array();

//fetch only v4
if( $o_4 == 1 && $o_6 == 0 )
{
  list($routes4, $asnlist4) = resolve_v4($irr, $object);
}
//fetch only v6
elseif( $o_6 == 1 && $o_4 == 0 )
{
  list($routes6, $asnlist6) = resolve_v6($irr, $object);
}
//fetch both
else
{
  list($routes4, $asnlist4) = resolve_v4($irr, $object);
  list($routes6, $asnlist6) = resolve_v6($irr, $object);
}

//check if either result set came back with nothing
if(empty($routes4)) { $routes4 = array(); }
if(empty($routes6)) { $routes6 = array(); }

//now lets take a quick break to convert v6 routes to all UPPER and clean up any duplicates - this may need to become a general function?
for ($i = 0; $i < count($routes6); ++$i) {
	$routes6[$i] = strtoupper($routes6[$i]);
}

$routes62 = array();
foreach($routes6 as $val) {   
	$routes62[$val] = TRUE;
}
$routes6 = array_keys($routes62); 

$routes = array_merge($routes4, $routes6);

if (!$o_aggregate) {
	for($i=0;$i<sizeof($routes);$i++)
		printf("%s\n", $routes[$i]);
} else {
	$tmpname = tempnam($cfg['paths']['tmp'], "IRRPT");

	if (!($tmp = fopen($tmpname, "w"))) {
		status(STATUS_ERROR, "Unable to open tmp file, aborting.");
		exit(-1);
	}

	for($i=0;$i<sizeof($routes);$i++)
		fwrite($tmp, sprintf("%s\n", $routes[$i]));

	fclose($tmp);

  /* Aggregate the route file */
  status(STATUS_NOTICE, "Aggregating routes.");
  $aggregated_routes = aggregate_routes($tmpname);

  /* print result */
  $count = count($aggregated_routes);
  for ($i = 1; $i < $count; $i++)
  {
    print "$aggregated_routes[$i]";
  }

	unlink($tmpname);
}

?>
